---
title: "final_cleaning"
output: html_document
date: "2024-12-27"
---

## *Downloading packages*

```{r}
install.packages("tidyr")
install.packages("dplyr")
library(tidyr)
library(dplyr)
```

## *Loading data*

```{r}
getwd()
setwd("~/Desktop/dataman_mod/CW/Group5")

files <- list.files(path = 'original_data', pattern='*.csv', full.names = TRUE)
print(files[1:3]) #prints first three files

sample_dat <- lapply((files), function(x){
  read.csv(x, header=FALSE, sep=",", row.names = 1)})
View(sample_dat)


print(sample_dat [1:3])
#NB: When working with larger files (e.g., when we do the whole dataset) can use the fread function from the data.table function instead

```

## *Ordering the row names*

```{r}
sample_dat_ordered <- lapply((sample_dat), function(y){
  y[order(row.names(y)), , drop=FALSE]
}) #Sort rows by their row names and orders them so they are all presented in the same order 

#drop = FALSE prevents them from being dropped/removed - losing dimension as a dataframe
#NB: did not check for missing rownames or duplicated rownames
```

```{r}
print(sample_dat_ordered[1:3])
View(sample_dat_ordered)

```

## *Rearranging the data using Tidyr*

```{r}
sample_dat_ordered <- as.data.frame(sample_dat_ordered) #convert into dataframe to make it quicker and more efficient to bind
new_sample_dat <- bind_cols(sample_dat_ordered)
new_sample_dat <- t(new_sample_dat)
View(new_sample_dat)
typeof(new_sample_dat)

is.data.frame(new_sample_dat) #FALSE
is.list(new_sample_dat) #FALSE 

#Currently character not dataframe so convert into dataframe 
new_sample_dat <- as.data.frame(new_sample_dat)
is.data.frame(new_sample_dat) #TRUE

new_sample_dat <- as.data.frame(lapply(new_sample_dat, type.convert, as.is = TRUE)) #Converts all the data in each column into the right datatypes
View(new_sample_dat)

```

## *Data Cleaning Step 1: Checking uniqueness of categories*

```{r}

#Check for NA's in all columns 
for (n in colnames(new_sample_dat)){
  print(sum(is.na(new_sample_dat[[n]])))
}
# 0 across all columns - No NA's found 
```

```{r echo=TRUE}
#First checking mouse_life_stages
print(unique(new_sample_dat[4])) #checking all inputted life stages
```

No abnormal life stages - no need for further cleaning

## *Checking mouse_strain*

```{r}
print(unique(new_sample_dat[5]))
print(unique(new_sample_dat[5] == 'C3H')) #[1] FALSE - there are no C3H strains
#21 unique values; should be 4 - need to remove 17 

sub_dat <- subset(new_sample_dat,mouse_strain %in% c('C57BL','129SV', 'C3H','B6J' ))

print(unique(sub_dat[5])) #Now we only have data files with either C57Bl, 129SV or B6J
View(sub_dat)
```

``` r
Description:df [21 Ã— 1]
 
 
mouse_strain
<chr>
1   C57BL           
2   C54BL           
5   C50BL           
108 C58BL           
137 129SV           
215 B6J         
291 C53BL           
349 C56BL           
1271    C52BL           
1713    C51BL           
1-10 of 21 rows
```

## *Checking p-value*

```{r}
min(sub_dat[8]) #checking the minimum p-value stored [1] 0 -> so it's within range
max(sub_dat[8]) #checking the maximum p-value stored [1] 1.499989 - so we need to restrict it to 1

sub_dat[8] <- mapply(function(x) min(1,x),sub_dat[[8]])
max(sub_dat[8]) # [1] 1 - now  within range

```

## *Checking gene_accession_id*

```{r}
#Check format of gene_accession_id 
#a. length = 9-11
#gene_accession_id is in column 2 
id_column <- sub_dat[[2]]
print(id_column)

# Count rows where the ID length is shorter than 9 or longer than 11
id_length <- (which(nchar(id_column) < 9 | nchar(id_column) > 11))
print(sub_dat[id_length,]) #Nothing printed so they are all the right length 

```

## *Checking for duplicated entries for gene symbol and gene accession_id*

-   Using the: gene_accession_id , gene_symbol, mouse_life_stage, and mouse_strain

-   If there are duplicated rows, need to check if their p-values are different or not

```{r}
print(unique(sub_dat[3])) #[1] 393 unique genes_symbols
print(unique(sub_dat[2])) #[1] 200 unique gene_accession_id

#Multiple gene symbols being used for one gene_accession_id 
#We need to find which gene id's have multiple gene symbols 

id_and_symbol_dat <- unique(sub_dat[2:3]) #paired dataframe containing all unique values of gene symbols and accession ids.
print(id_and_symbol_dat)

id_symbols <- aggregate(id_and_symbol_dat[2],list(gene_id = id_and_symbol_dat$gene_accession_id),function(x) x)
View(id_symbols) #aggregate - group of paired sets

print(unique(mapply(length,id_symbols$gene_symbol))) #[1] 1 2 - for each accession id it either has one gene symbol input or two gene symbol input => there are no more than two genes for each id. 

dup_flag <- mapply(function(x) length(x) > 1,id_symbols$gene_symbol)
dup_genes <- subset(id_symbols,dup_flag)
print(dup_genes)

```

``` r
sub_dat$gene_accession_id sub_dat$gene_symbol
1 MGI:103225               c("Cyp4b1", "CYP4B1")
2 MGI:104629               c("Penk", "PENK")
3 MGI:105304               c("Il6ra", "IL6RA")
4 MGI:106924               c("Melk", "MELK")
5 MGI:107164               c("Ppp3ca", "PPP3CA")
```

-   All duplications are due to differences in entries as lower case and upper case - can remove the uppercase entries and replace with lowercase

```{r}
install.packages("stringr")
library(stringr)
apply_lower_case <- str_to_title(sub_dat$gene_symbol) #str_to_title function from stringr capitalizes the first character and applies lowercase on rest of string
sub_dat$gene_symbol <- apply_lower_case
View(sub_dat)

print(unique(sub_dat[3])) #[1] 200 - matches the number of unique gene accession_ids
```


## Checking p-values for same parameters are not different 

- checking to see if there are repeated entries for parameter_id and parameter_name --> TRUE
- grouping rows with identical information (except analysis_id)
- are there different p-values ?
- did not find any repeated entries with differing p-values 

```{r, echo=TRUE}

any(duplicated(sub_dat$parameter_id))
any(duplicated(sub_dat$parameter_name))

length(unique(sub_dat$parameter_id[duplicated(sub_dat$parameter_id)])) 
#260 repeated parameter_names & 325 repeated parameter_ids 

#working without analysis_id column
check_pvalue_data <- sub_dat[,2:8]

# filtering identical entries but different p-values
identical_cols <- c("analysis_id","gene_accession_id","gene_symbol","mouse_life_stage","mouse_strain","parameter_id","parameter_name")

diff_pvalues <- sub_dat %>%
  group_by(across(all_of(identical_cols))) %>%
  filter(n_distinct(pvalue) > 1) %>% #keep grps with distinct p-values 
  ungroup()

View(diff_pvalues) #no confliciting p-values 

```

